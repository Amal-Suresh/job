"use strict";(self.webpackChunkjob=self.webpackChunkjob||[]).push([[614],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=u(n),m=o,h=c["".concat(l,".").concat(m)]||c[m]||d[m]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:o,i[1]=s;for(var u=2;u<r;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8847:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>u});var a=n(7462),o=(n(7294),n(3905));const r={sidebar_position:3,title:"Frontend"},i="Frontend Questions",s={unversionedId:"questions/frontend",id:"questions/frontend",title:"Frontend",description:"Ways to store data on client?",source:"@site/interview/questions/frontend.md",sourceDirName:"questions",slug:"/questions/frontend",permalink:"/interview/questions/frontend",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/questions/frontend.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Frontend"},sidebar:"tutorialSidebar",previous:{title:"Typescript",permalink:"/interview/questions/typescript"},next:{title:"NodeJS",permalink:"/interview/questions/nodejs"}},l={},u=[{value:"Ways to store data on client?",id:"ways-to-store-data-on-client",level:3},{value:"What is a SPA and how to make it SEO-friendly?",id:"what-is-a-spa-and-how-to-make-it-seo-friendly",level:3},{value:"What is DOM?",id:"what-is-dom",level:3},{value:"SPA vs MPA",id:"spa-vs-mpa",level:3},{value:"What is the difference between attributes and properties?",id:"what-is-the-difference-between-attributes-and-properties",level:3},{value:"ReactJS",id:"reactjs",level:2}],p={toc:u};function c(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"frontend-questions"},"Frontend Questions"),(0,o.kt)("h3",{id:"ways-to-store-data-on-client"},"Ways to store data on client?"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Cookies"),(0,o.kt)("li",{parentName:"ol"},"Web Storage API (local/session)"),(0,o.kt)("li",{parentName:"ol"},"IndexDB"),(0,o.kt)("li",{parentName:"ol"},"JS variables"),(0,o.kt)("li",{parentName:"ol"},"DOM Node Storage (dataset property or setAttribute(), getAttribute(), eg: someElement.dataset.store = \u2018some value\u2019)"),(0,o.kt)("li",{parentName:"ol"},"Cache API")),(0,o.kt)("h3",{id:"what-is-a-spa-and-how-to-make-it-seo-friendly"},"What is a SPA and how to make it SEO-friendly?"),(0,o.kt)("h3",{id:"what-is-dom"},"What is DOM?"),(0,o.kt)("h3",{id:"spa-vs-mpa"},"SPA vs MPA"),(0,o.kt)("h3",{id:"what-is-the-difference-between-attributes-and-properties"},"What is the difference between attributes and properties?"),(0,o.kt)("ol",{start:6},(0,o.kt)("li",{parentName:"ol"},"\u0427\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u0440\u0430\u0441\u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f (Event Propogation)?"),(0,o.kt)("li",{parentName:"ol"},"\u0427\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u0432\u0441\u043f\u043b\u044b\u0442\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f (Event Bubbling)?"),(0,o.kt)("li",{parentName:"ol"},"\u0427\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u043f\u043e\u0433\u0440\u0443\u0436\u0435\u043d\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f (Event Capturing)?")),(0,o.kt)("p",null,"In JavaScript, attributes and properties are both used to store data in an object or an element, but they have some important differences."),(0,o.kt)("p",null,"An attribute is a default value that is defined in the HTML code of an element, and it can be accessed using the ",(0,o.kt)("inlineCode",{parentName:"p"},"getAttribute()")," method of the element. An attribute reflects the default value of an element, and it can be modified using the ",(0,o.kt)("inlineCode",{parentName:"p"},"setAttribute()")," method."),(0,o.kt)("p",null,"A property is a value that is associated with an object or an element, and it can be accessed and modified using the dot notation (e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"object.property"),") or the square bracket notation (e.g., ",(0,o.kt)("inlineCode",{parentName:"p"},"object['property']"),"). A property reflects the current state of an object or an element, and it is typically used to store data that is related to the object or element."),(0,o.kt)("p",null,"Here is an example that illustrates the difference between attributes and properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},'<input type="text" id="input" value="Hello">\n\nconst input = document.getElementById(\'input\');\n\nconsole.log(input.getAttribute(\'value\'));  // logs "Hello"\nconsole.log(input.value);  // logs "Hello"\n\ninput.setAttribute(\'value\', \'World\');\nconsole.log(input.getAttribute(\'value\'));  // logs "World"\nconsole.log(input.value);  // logs "Hello"\n\ninput.value = \'Hello\';\nconsole.log(input.getAttribute(\'value\'));  // logs "World"\nconsole.log(input.value);  // logs "Hello"\n')),(0,o.kt)("p",null,"In this example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"input")," element has a ",(0,o.kt)("inlineCode",{parentName:"p"},"value"),' attribute with the default value "Hello". The ',(0,o.kt)("inlineCode",{parentName:"p"},"input")," element also has a ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," property that reflects the current value of the element."),(0,o.kt)("p",null,"When the ",(0,o.kt)("inlineCode",{parentName:"p"},"getAttribute()")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"setAttribute()")," methods are used, the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," attribute is accessed and modified, while the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," property remains unchanged. On the other hand, when the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," property is modified using the dot notation, the ",(0,o.kt)("inlineCode",{parentName:"p"},"value")," attribute."),(0,o.kt)("h2",{id:"reactjs"},"ReactJS"),(0,o.kt)("p",null,'HTML/CSS\n\u2022 \u0421\u0435\u043c\u0430\u043d\u0442\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0432\u0435\u0440\u0441\u0442\u043a\u0430\n\u2022 CSS \u0441\u0435\u043b\u0435\u043a\u0442\u043e\u0440\u044b\n\u2022 \u041a\u0430\u043a\u0438\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0442 \u0442\u0438\u043f\u044b \u0441\u0442\u0438\u043b\u0435\u0439 css \u0434\u043b\u044f html: inline css, external stylesheet, internal stylesheet\n\u2022 \u0422\u0438\u043f\u044b \u0433\u0440\u0430\u0444\u0438\u043a\u0438 \u0432 html: canvas and svg\nReactJS\n\u2022 \u041a\u0440\u0430\u0442\u043a\u043e \u0440\u0430\u0441\u0441\u043a\u0430\u0437\u0430\u0442\u044c, \u0447\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u0440\u0435\u0430\u043a\u0442:\n\u2022 Props vs State\n\u2022 \u0420\u0430\u0441\u0441\u043a\u0430\u0436\u0438 \u043e \u043f\u0440\u0435\u0438\u043c\u0443\u0449\u0435\u0441\u0442\u0432\u0430\u0445 \u0438 \u043d\u0435\u0434\u043e\u0441\u0442\u0430\u0442\u043a\u0430\u0445 \u0440\u0435\u0430\u043a\u0442\u0430:\n\u2022 \u0427\u0442\u043e \u0442\u0430\u043a\u043e\u0435 Virtual DOM:\n\u2022 \u0427\u0442\u043e \u0442\u0430\u043a\u043e\u0435 JSX, \u0434\u043b\u044f \u0447\u0435\u0433\u043e \u043c\u044b \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c className, \u0430 \u043d\u0435 class:\n\u2022 \u0427\u0442\u043e \u0442\u0430\u043a\u043e\u0435 \u0420\u0435\u0430\u043a\u0442 \u041a\u043e\u043c\u043f\u043e\u043d\u0435\u043d\u0442:\n\u2022 State vs Props:\nProps get passed to the component similar to function parameters\nState is managed within the component similar to variables declared within a function.\n\u2022 Controlled vs Uncontrolled components:\nA Controlled Component is one that takes its current value through props and notifies changes through callbacks like onChange. A parent component "controls" it by handling the callback and managing its own state and passing the new values as props to the controlled component. You could also call this a "dumb component".\nA Uncontrolled Component is one that stores its own state internally, and you query the DOM using a ref to find its current value when you need it. This is a bit more like traditional HTML.\n\u2022 \u041e\u043f\u0438\u0441\u0430\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u0443 React lifecycle:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"\u2022 \u041e\u043f\u0438\u0441\u0430\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u0443 \u0441 Redux, \u043f\u0440\u0438\u043d\u0446\u0438\u043f\u044b (single source of truth, state is read-only (action creator, reducer), Changes are made with pure functions)\n\u2022 Redux: mapStateToProps vs mapDispatchToProps\n\u2022 What are the differences between redux-saga and redux-thunk?\n")),(0,o.kt)("p",null,"Both Redux Thunk and Redux Saga take care of dealing with side effects. In most of the scenarios, Thunk uses Promises to deal with them, whereas Saga uses Generators. Thunk is simple to use and Promises are familiar to many developers, Sagas/Generators are more powerful but you will need to learn them. But both middleware can coexist, so you can start with Thunks and introduce Sagas when/if you need them.\n\u2022 React Context API"),(0,o.kt)("p",null,"\u2022 \u041a\u0430\u043a\u0438\u0435 \u0441\u043f\u043e\u0441\u043e\u0431\u044b \u0440\u0430\u0431\u043e\u0442\u044b css and react \u0437\u043d\u0430\u0435\u0448\u044c \u0438 \u043a\u0430\u043a\u043e\u0439 \u043f\u0440\u0435\u0434\u043f\u043e\u0447\u0442\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0439 (className and css/scss/stylus/modules; inline styles; CSS-in-JS)\n\u2022 \u0420\u0430\u0441\u0441\u043a\u0430\u0437\u0430\u0442\u044c \u043e \u0432\u044b\u0431\u0440\u0430\u043d\u043d\u044b\u0445 \u0438\u043d\u0441\u0442\u0440\u0443\u043c\u0435\u043d\u0442\u0430\u0445 \u0434\u043b\u044f \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u044f \u043e\u0434\u043d\u043e\u0441\u0442\u0440\u0430\u043d\u0438\u0447\u043d\u043e\u0433\u043e \u0441\u0430\u0439\u0442\u0430 \u0441 \u043a\u043e\u043d\u0442\u0430\u043a\u0442\u043d\u043e\u0439 \u0444\u043e\u0440\u043c\u043e\u0439\n\u2022 \u0418\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u0435 Ref\n\u2022 \u0421\u0438\u043d\u0442\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u0441\u043e\u0431\u044b\u0442\u0438\u044f (SynteticEvent) \u0447\u0442\u043e \u0442\u0430\u043a\u043e\u0435, \u0437\u0430\u0447\u0435\u043c \u043f\u0440\u0438\u0434\u0443\u043c\u0430\u043d\u043e\n\u2022 Routing\n\u2022 Functional components vs Class components:\n\u2022 React Hooks: Explain why and when would you use useMemo()?\nAnswer\nWhy:\nIn the lifecycle of a component, React re-renders the component when an update is made. When React checks for any changes in a component, it may detect an unintended or unexpected change due to how JavaScript handles equality and shallow comparisons. This change in the React application will cause it to re-render unnecessarily."),(0,o.kt)("p",null,"Additionally, if that re-rendering is an expensive operation, like a long for loop, it can hurt performance. Expensive operations can be costly in either time, memory, or processing."),(0,o.kt)("p",null,"When:\nOptimal if the wrapped function is large and expensive."),(0,o.kt)("p",null,"How:\nMemoization is an optimization technique which passes a complex function to be memoized. In memoization, the result is \u201cremembered\u201d when the same parameters are passed-in subsequently."),(0,o.kt)("p",null,"const memoizedValue = React.useMemo(() => computeExpensiveValue(a, b), ","[a, b]",");\nuseMemo takes in a function and an array of dependencies. The dependency\u2019s list are the elements useMemo watches: if there are no changes, the function result will stay the same. Otherwise, it will re-run the function. If they don\u2019t change, it doesn\u2019t matter if our entire component re-renders, the function won\u2019t re-run but instead return the stored result.\n\u2022 \u041f\u0440\u043e\u0431\u043b\u0435\u043c\u0430 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0433\u043e \u043a\u043e\u0434\u0430:\nthis.setState({\ncounter: this.state.counter + this.props.increment,\n});\nAnswer\nBecause this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state. To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:\n// Correct\nthis.setState((state, props) => ({\ncounter: state.counter + props.increment\n}));\n\u2022 \u0420\u0430\u0437\u043d\u0438\u0446\u0430 \u043c\u0435\u0436\u0434\u0443 useCallback \u0438 useMemo?\nWith useCallback you memoize functions, useMemo memoizes any computed value:\nconst fn = () => 42 // assuming expensive calculation here\nconst memoFn = useCallback(fn, ","[dep]",") // (1)\nconst memoFnReturn = useMemo(fn, ","[dep]",") // (2)\n(1) will return a memoized version of fn - same reference across multiple renders, as long as dep is the same. But every time you invoke memoFn, that complex computation starts again.\n(2) will invoke fn every time dep changes and remember its returned value (42 here), which is then stored in memoFnReturn.\n\u2022 \u0412"))}c.isMDXComponent=!0}}]);