"use strict";(self.webpackChunkjob=self.webpackChunkjob||[]).push([[374],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=i,y=c["".concat(l,".").concat(h)]||c[h]||u[h]||r;return n?a.createElement(y,o(o({ref:t},d),{},{components:n})):a.createElement(y,o({ref:t},d))}));function y(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},7842:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const r={sidebar_position:2},o="Typescript",s={unversionedId:"questions/typescript",id:"questions/typescript",title:"Typescript",description:"What is TypeScript, and its benefits?",source:"@site/interview/questions/typescript.md",sourceDirName:"questions",slug:"/questions/typescript",permalink:"/interview/questions/typescript",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/questions/typescript.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Javascript",permalink:"/interview/questions/javascript"},next:{title:"Frontend",permalink:"/interview/questions/frontend"}},l={},p=[{value:"What is TypeScript, and its benefits?",id:"what-is-typescript-and-its-benefits",level:3},{value:"What is the typeof operator?",id:"what-is-the-typeof-operator",level:3},{value:"Difference void vs undefined",id:"difference-void-vs-undefined",level:3},{value:"What is an unknown type?",id:"what-is-an-unknown-type",level:3},{value:"Why to use never?",id:"why-to-use-never",level:3},{value:"Interfaces vs Types",id:"interfaces-vs-types",level:3},{value:"What is enum and why to use?",id:"what-is-enum-and-why-to-use",level:3},{value:"What is difference between enum vs const?",id:"what-is-difference-between-enum-vs-const",level:3},{value:"Tell about \u2018as\u2019 syntax in TypeScript",id:"tell-about-as-syntax-in-typescript",level:3},{value:"Describe Unions and Intersection Types",id:"describe-unions-and-intersection-types",level:3},{value:"What is abstract class and why to use it?",id:"what-is-abstract-class-and-why-to-use-it",level:3},{value:"What is the \u2018implement\u2019 clause?",id:"what-is-the-implement-clause",level:3},{value:"What are Decorators?",id:"what-are-decorators",level:3},{value:"Tell about public vs private vs protected",id:"tell-about-public-vs-private-vs-protected",level:3},{value:"Function overloading typescript",id:"function-overloading-typescript",level:3},{value:"What is the use of the tsconfig.json file?",id:"what-is-the-use-of-the-tsconfigjson-file",level:3},{value:"What is the declare Keyword in TypeScript?",id:"what-is-the-declare-keyword-in-typescript",level:3},{value:"What are Mixins?",id:"what-are-mixins",level:3},{value:"What is Namespace and how to declare it?",id:"what-is-namespace-and-how-to-declare-it",level:3},{value:"What are Generics?",id:"what-are-generics",level:3},{value:"What are template literal types?",id:"what-are-template-literal-types",level:3},{value:"What is conditional type and how to create?",id:"what-is-conditional-type-and-how-to-create",level:3},{value:"What utility types exist and their usage",id:"what-utility-types-exist-and-their-usage",level:3}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"typescript"},"Typescript"),(0,i.kt)("h3",{id:"what-is-typescript-and-its-benefits"},"What is TypeScript, and its benefits?"),(0,i.kt)("p",null,"TypeScript is a programming language that is based on JavaScript, and it is designed to add optional static typing and other features to JavaScript. TypeScript is a typed superset of JavaScript, which means that any valid JavaScript code is also valid TypeScript code, and TypeScript adds additional features and syntax to the language."),(0,i.kt)("p",null,"Benefits of using TypeScript include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Static typing: TypeScript adds optional static typing to JavaScript, which allows you to specify the types of variables, function arguments, and return values. This can help to catch type-related errors at compile time, rather than at runtime, and it can make the code easier to understand and debug."),(0,i.kt)("li",{parentName:"ul"},"Improved code completion: TypeScript provides improved code completion and IntelliSense in code editors and IDEs, which can help to make the code easier to write and navigate."),(0,i.kt)("li",{parentName:"ul"},"Improved code documentation: TypeScript allows you to add type annotations and documentation comments to the code, which can help to make the code more self-explanatory and easier to understand."),(0,i.kt)("li",{parentName:"ul"},"Improved code refactoring: TypeScript's static typing and improved code completion and IntelliSense can make it easier to refactor and modify the code, as it can help to catch errors and provide suggestions for alternatives.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"TypeScript is particularly useful for projects with a large codebase or a team of developers. It can help to improve the quality and reliability of the code, and to make it easier to understand and maintain.")),(0,i.kt)("h3",{id:"what-is-the-typeof-operator"},"What is the typeof operator?"),(0,i.kt)("p",null,"It returns type of given value."),(0,i.kt)("h3",{id:"difference-void-vs-undefined"},"Difference void vs undefined"),(0,i.kt)("p",null,"In TypeScript, ",(0,i.kt)("inlineCode",{parentName:"p"},"void")," is a type that represents the absence of a value. The ",(0,i.kt)("inlineCode",{parentName:"p"},"void")," type is used to indicate that a function does not return a value, or that a variable or expression has no value."),(0,i.kt)("p",null,"On the other hand, ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," is a value that represents the absence of a value or a variable that has not been assigned a value. In JavaScript and TypeScript, ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," is a primitive value that represents the absence of a value or a variable that has not been assigned a value."),(0,i.kt)("h3",{id:"what-is-an-unknown-type"},"What is an unknown type?"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"unknown")," type is used to represent values that are not known or that cannot be determined at compile time, such as values that are returned from external APIs or libraries, or values that are derived from user input or runtime calculations. The ",(0,i.kt)("inlineCode",{parentName:"p"},"unknown")," type is more restrictive than the ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," type, as it requires explicit type assertions or type guards to narrow the type of the value before it can be used or accessed."),(0,i.kt)("h3",{id:"why-to-use-never"},"Why to use never?"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"never")," type is used to represent values that are never expected to occur or that are not intended to be used, such as the result of a function that always throws an exception or an infinite loop that never returns. The ",(0,i.kt)("inlineCode",{parentName:"p"},"never")," type is a useful way to express the absence of a value or the impossibility of a scenario, and it can help to prevent errors and improve code quality by indicating that a value or a function is not intended to be used or accessed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function fail(message: string): never {\n  throw new Error(message);\n}\n\nfunction infiniteLoop(): never {\n  while (true) {\n    // ...\n  }\n}\n\nlet x: never = fail('Something went wrong');  // ok\nlet y: never = infiniteLoop();  // ok\n\nlet z: number = x;  // error: Type 'never' is not assignable to type 'number'\nlet w: string = x;  // error: Type 'never' is not assignable to type 'string'\n")),(0,i.kt)("h3",{id:"interfaces-vs-types"},"Interfaces vs Types"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"different syntax")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface SetPoint {\n    (x: number, y: number): void;\n}\n\ntype SetPoint = (x: number, y: number) => void;\n\n// extening\ninterface PartialPointX {\n    x: number;\n}\ninterface Point extends PartialPointX {\n    y: number;\n}\n\ntype PartialPointX = { x: number };\ntype Point = PartialPointX & { y: number };\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"other type creation only with type:")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// primitive\ntype Name = string;\n\n// object\ntype PartialPointX = { x: number };\ntype PartialPointY = { y: number };\n\n// map\ntype TMap = new Map<string, number>;\n\n// union\ntype PartialPoint = PartialPointX | PartialPointY;\n\n// tuple\ntype Data = [number, string];\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Both can be implemented by classes"),(0,i.kt)("li",{parentName:"ul"},"interface merging")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface Point {\n    x: number;\n}\ninterface Point {\n    y: number;\n}\n\nconst point: Point = { x: 1, y: 2 };\n")),(0,i.kt)("h3",{id:"what-is-enum-and-why-to-use"},"What is enum and why to use?"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"enum")," is a way to define a set of related values that can be used to represent a specific set of choices or options. An ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," is a named group of constants, and it allows you to create a set of named values that can be used to represent a specific set of choices or options."),(0,i.kt)("p",null,"The purpose of using an ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," in TypeScript is to create a named group of constants that can be used to represent a specific set of choices or options. An ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," can help to make the code more readable and maintainable by providing a clear and concise way to represent a set of related values, and it can help to enforce a consistent and standardized approach to using these values in the code."),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," can also be used to create a set of related values that can be used as keys or indexes in an array or an object, or as arguments or parameters in a function or a method. An ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," can be used to create a set of values that can be used in a more structured and organized way, and it can help to avoid errors and inconsistencies in the code."),(0,i.kt)("h3",{id:"what-is-difference-between-enum-vs-const"},"What is difference between enum vs const?"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"enum EColors {\n    Red = 'red',\n    Green = 'green',\n    Blue = 'blue',\n}\n\nconst COLORS = {\n    Red: 'red',\n    Green: 'green',\n    Blue: 'blue',\n} as const;\n")),(0,i.kt)("p",null,"There are some differences between using an ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"const")," object to define a set of related values in TypeScript:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Naming:")," An ",(0,i.kt)("inlineCode",{parentName:"li"},"enum")," allows you to define a set of named values, while a ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," object allows you to define an object with a fixed set of properties and values. An ",(0,i.kt)("inlineCode",{parentName:"li"},"enum")," can be easier to read and understand, as it provides a clear and concise way to represent a set of related values, while a ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," object can be more verbose and less intuitive, as it requires you to define the properties and values of the object explicitly."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Values:")," An ",(0,i.kt)("inlineCode",{parentName:"li"},"enum")," assigns default values to its constants, which are typically numbers starting from ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),", but you can also specify custom values for the constants if needed. A ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," object does not assign any values to its properties, and you have to specify the values of the properties explicitly."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Type compatibility:")," An ",(0,i.kt)("inlineCode",{parentName:"li"},"enum")," is a type in TypeScript, and it can be used as a type parameter, a type argument, a function return type, or a variable type. A ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," object is not a type in TypeScript, and it cannot be used in these contexts. Instead, you can use the type of the properties of a ",(0,i.kt)("inlineCode",{parentName:"li"},"const")," object, or create an interface or a type alias to represent the structure of the object.")),(0,i.kt)("h3",{id:"tell-about-as-syntax-in-typescript"},"Tell about \u2018as\u2019 syntax in TypeScript"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," syntax in TypeScript is used to perform type assertions, which allow you to override the type of a value and tell the compiler that you know the type of the value more specifically. Type assertions are a way to provide additional type information to the compiler, and they can be useful when you want to narrow the type of a value or when you want to use a value in a context where the compiler cannot infer the correct type."),(0,i.kt)("p",null,'Type assertions can be used in two forms: the "angle-bracket" syntax, and the ',(0,i.kt)("inlineCode",{parentName:"p"},"as")," syntax. The angle-bracket syntax uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"<>")," characters to enclose the type that you want to assert, and it is typically used for type assertions on primitive types. The ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," syntax uses the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," keyword followed by the type that you want to assert, and it is typically used for type assertions on object types."),(0,i.kt)("p",null,"Here is an example of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"as")," syntax for type assertions in TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let x: any = 'Hello';\n\nlet y = x as string;  // type of y is 'string'\n\nlet z: number = y as any;  // type of z is 'number'\n")),(0,i.kt)("p",null,"Type assertions can be a useful technique in TypeScript, as they allow you to provide additional type information to the compiler and to override the type of a value when necessary. It is important to use type assertions appropriately, as they can affect the type safety and reliability of the code."),(0,i.kt)("h3",{id:"describe-unions-and-intersection-types"},"Describe Unions and Intersection Types"),(0,i.kt)("p",null,"In TypeScript, union types and intersection types are ways to specify multiple types for a single value."),(0,i.kt)("p",null,"A union type represents a value that can be of one of several types. Union types are denoted using the ",(0,i.kt)("inlineCode",{parentName:"p"},"|")," character, and they allow you to specify that a value can be of multiple types. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"let x: string | number;\n\nx = 'hello';  // valid\nx = 42;       // valid\nx = true;     // invalid\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," variable is declared as a union type of ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", which means that it can hold a value of either type. The value of ",(0,i.kt)("inlineCode",{parentName:"p"},"x")," can be set to a ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," or a ",(0,i.kt)("inlineCode",{parentName:"p"},"number"),", but not to a ",(0,i.kt)("inlineCode",{parentName:"p"},"boolean")," or any other type."),(0,i.kt)("p",null,"An intersection type represents a value that is of multiple types. Intersection types are denoted using the ",(0,i.kt)("inlineCode",{parentName:"p"},"&")," character, and they allow you to specify that a value must be of multiple types. For example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type User = {\n  name: string;\n  age: number;\n};\n\ntype Admin = {\n  role: string;\n};\n\ntype SuperUser = User & Admin;\n\nconst user: SuperUser = {\n  name: 'John',\n  age: 42,\n  role: 'admin'\n};\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Admin")," types are defined, and they represent objects with different properties. The ",(0,i.kt)("inlineCode",{parentName:"p"},"SuperUser")," type is defined as an intersection of ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Admin"),", which means that it represents an object that must have both the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"age")," properties of the ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," type, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"role")," property of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Admin")," type."),(0,i.kt)("h3",{id:"what-is-abstract-class-and-why-to-use-it"},"What is abstract class and why to use it?"),(0,i.kt)("p",null,"It is a class that cannot be instantiated directly, and that is intended to be used as a base class for one or more derived classes. Abstract classes are used to define the common behavior and the shared structure of a group of related classes, and they provide a way to implement inheritance and polymorphism in TypeScript."),(0,i.kt)("p",null,"An abstract class is defined using the ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract")," keyword, and it can contain both abstract and concrete members. Abstract members are members that are declared but not implemented, and they must be implemented by the derived classes. Concrete members are members that are declared and implemented, and they can be used directly by the derived classes."),(0,i.kt)("h3",{id:"what-is-the-implement-clause"},"What is the \u2018implement\u2019 clause?"),(0,i.kt)("p",null,"It is used to specify that a class or an object implements an interface or a class. An interface is a type that defines a set of properties, methods, and events that a class or an object must have or must implement. A class is a blueprint for creating objects, and it can define the structure and the behavior of the objects it creates."),(0,i.kt)("h3",{id:"what-are-decorators"},"What are Decorators?"),(0,i.kt)("p",null,"In TypeScript, decorators are a way to add additional behavior to classes, methods, properties, and other elements of the code. Decorators are functions that are invoked with a special syntax, and they can be used to modify or extend the behavior of the decorated element in various ways."),(0,i.kt)("p",null,"Decorators are typically used to add metadata or to implement cross-cutting concerns, such as logging, validation, or error handling. They can be applied to classes, methods, properties, accessors, parameters, or even local variables, and they can be defined and used in different ways."),(0,i.kt)("p",null,"Here is an example of using a decorator in TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n\n  descriptor.value = function(...args: any[]) {\n    console.log(`${propertyKey} method called with arguments: ${args}`);\n    return originalMethod.apply(this, args);\n  }\n\n  return descriptor;\n}\n\nclass MyClass {\n  @log\n  public method1(a: number, b: number): number {\n    return a + b;\n  }\n}\n\nconst obj = new MyClass();\nobj.method1(1, 2);  // logs: 'method1 method called with arguments: [1, 2]'\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"log")," decorator is defined as a function that takes three parameters: the target object, the name of the decorated property, and the property descriptor. The decorator modifies the ",(0,i.kt)("inlineCode",{parentName:"p"},"value")," property of the descriptor to wrap the original method in a logging function, and it returns the modified descriptor. The ",(0,i.kt)("inlineCode",{parentName:"p"},"@log")," decorator is applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"method1")," method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyClass")," class, and it logs the arguments of the method whenever it is called."),(0,i.kt)("p",null,"Decorators are a powerful and flexible feature of TypeScript that can be used to add additional behavior to the code, and they can be useful for implementing cross-cutting concerns and for creating reusable and modular code. It is important to use decorators appropriately to ensure that they do not interfere with the intended behavior of the code, and to make the code easy to understand and maintain."),(0,i.kt)("h3",{id:"tell-about-public-vs-private-vs-protected"},"Tell about public vs private vs protected"),(0,i.kt)("p",null,"In TypeScript, there are three access modifiers that can be used to control the visibility and accessibility of class members (fields and methods):"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"public"),": Members that are marked as ",(0,i.kt)("inlineCode",{parentName:"li"},"public")," are visible and accessible from anywhere within the class, as well as from outside the class. ",(0,i.kt)("inlineCode",{parentName:"li"},"public")," is the default access modifier for class members, and it is not necessary to explicitly specify it."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"private"),": Members that are marked as ",(0,i.kt)("inlineCode",{parentName:"li"},"private")," are visible and accessible only within the class where they are defined. They are not visible or accessible from outside the class."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"protected"),": Members that are marked as ",(0,i.kt)("inlineCode",{parentName:"li"},"protected")," are visible and accessible within the class where they are defined, and they are also visible and accessible to derived classes (classes that inherit from the class where the members are defined).")),(0,i.kt)("p",null,"Access modifiers in TypeScript can help to control the visibility and accessibility of class members, and they can help to make the code more modular, maintainable, and secure. It is important to use access modifiers appropriately to ensure that the code is organized and easy to understand, and to prevent unintended access to sensitive or private data."),(0,i.kt)("h3",{id:"function-overloading-typescript"},"Function overloading typescript"),(0,i.kt)("p",null,"Function overloading in TypeScript allows you to define multiple versions of a function with different types and numbers of parameters. This can be useful when you want to provide different behavior or functionality depending on the input to the function."),(0,i.kt)("p",null,"To define function overloading in TypeScript, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"function")," keyword followed by the name of the function, and then define multiple function signatures that specify the types and numbers of the parameters. The implementation of the function can vary depending on the signature that is matched."),(0,i.kt)("p",null,"Here is an example of function overloading in TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"function add(x: number, y: number): number;\nfunction add(x: string, y: string): string;\nfunction add(x: any, y: any): any {\n  if (typeof x === 'number' && typeof y === 'number') {\n    return x + y;\n  } else if (typeof x === 'string' && typeof y === 'string') {\n    return x + y;\n  } else {\n    throw new Error('Invalid arguments');\n  }\n}\n\nconsole.log(add(1, 2));  // 3\nconsole.log(add('Hello', ' world'));  // 'Hello world'\n")),(0,i.kt)("h3",{id:"what-is-the-use-of-the-tsconfigjson-file"},"What is the use of the tsconfig.json file?"),(0,i.kt)("p",null,"The tsconfig.json file is a JSON format file where you may specify several options to inform the compiler how to compile a project. The presence of this file in the directory implies that it is the TypeScript project root."),(0,i.kt)("h3",{id:"what-is-the-declare-keyword-in-typescript"},"What is the declare Keyword in TypeScript?"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"declare")," keyword in TypeScript is used to tell the compiler that a given symbol is already defined elsewhere, and that it should not try to generate any code for it. This is commonly used for ambient declarations, which are declarations that are not meant to be implemented, but rather to provide a type and/or shape for the code that is using them."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"declare")," keyword can be used to define variables, functions, classes, and other types of symbols, and it can be used in conjunction with other TypeScript features, such as interfaces and type aliases."),(0,i.kt)("p",null,"Here is an example of using the ",(0,i.kt)("inlineCode",{parentName:"p"},"declare")," keyword in TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"declare const MY_CONSTANT: string;\n\nconsole.log(MY_CONSTANT);  // 'Hello World'\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"MY_CONSTANT")," variable is declared with the ",(0,i.kt)("inlineCode",{parentName:"p"},"declare")," keyword, and it is assigned the type ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),". The compiler is told that the ",(0,i.kt)("inlineCode",{parentName:"p"},"MY_CONSTANT")," variable is already defined elsewhere, and that it should not generate any code for it."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"declare")," keyword is commonly used in TypeScript for ambient declarations, and it can be useful for providing type information for code that is written in other languages, or for code that is defined in external libraries or modules. It can help to improve the type safety and reliability of the code, and to make it easier to understand and maintain."),(0,i.kt)("h3",{id:"what-are-mixins"},"What are Mixins?"),(0,i.kt)("p",null,"Mixins are a way to reuse a set of functions or properties in multiple classes, without using inheritance or composition. Mixins allow you to define a common behavior or functionality that can be shared by multiple classes, and they can be used to avoid duplication and to create more modular and flexible code."),(0,i.kt)("p",null,"To define a mixin in TypeScript, you can create a function or a class that contains the common behavior or functionality, and then use the ",(0,i.kt)("inlineCode",{parentName:"p"},"mixin")," helper function to apply the mixin to one or more target classes. The ",(0,i.kt)("inlineCode",{parentName:"p"},"mixin")," helper function creates a new class that combines the target class with the mixin, and it returns the resulting class."),(0,i.kt)("p",null,"Here is an example of using mixins in TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function Timestamps<T extends new(...args: any[]) => {}>(Base: T) {\n  return class extends Base {\n    createdAt = new Date();\n    updatedAt = new Date();\n  };\n}\n\nclass User {\n  name: string;\n  age: number;\n}\n\nconst TimestampedUser = Timestamps(User);\n\nconst user = new TimestampedUser();\nuser.name = 'John';\nuser.age = 42;\nconsole.log(user.createdAt);  // current date and time\nconsole.log(user.updatedAt);  // current date and time\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Timestamps")," mixin is defined as a function that takes a ",(0,i.kt)("inlineCode",{parentName:"p"},"Base")," class as a parameter, and it returns a new class that extends the ",(0,i.kt)("inlineCode",{parentName:"p"},"Base")," class and adds the ",(0,i.kt)("inlineCode",{parentName:"p"},"createdAt")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"updatedAt")," properties. The ",(0,i.kt)("inlineCode",{parentName:"p"},"TimestampedUser")," class is created by applying the ",(0,i.kt)("inlineCode",{parentName:"p"},"Timestamps")," mixin to the ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," class, and it combines the properties and methods of the ",(0,i.kt)("inlineCode",{parentName:"p"},"User")," class with the ",(0,i.kt)("inlineCode",{parentName:"p"},"createdAt")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"updatedAt")," properties of the mixin."),(0,i.kt)("p",null,"Mixins are a useful technique in TypeScript for reusing common behavior or functionality in multiple classes, and they can help to create more modular and flexible code. It is important to use mixins appropriately, as they can affect the inheritance hierarchy and the type compatibility of the code, and to make sure that the mixins do not interfere with the intended behavior of the code."),(0,i.kt)("h3",{id:"what-is-namespace-and-how-to-declare-it"},"What is Namespace and how to declare it?"),(0,i.kt)("p",null,"In TypeScript, a namespace is a way to organize and group related code under a single name. Namespaces allow you to define and expose a set of variables, functions, classes, and other types of symbols, and to prevent naming conflicts and collisions with other code."),(0,i.kt)("p",null,"To declare a namespace in TypeScript, you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace")," keyword followed by the name of the namespace, and then enclose the code that you want to include in the namespace within curly braces. You can define variables, functions, classes, and other types of symbols inside the namespace, and you can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"export")," keyword to expose them to other parts of the code."),(0,i.kt)("p",null,"Here is an example of declaring a namespace in TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"namespace MyNamespace {\n  export const MY_CONSTANT = 'Hello World';\n\n  export function myFunction(x: number, y: number): number {\n    return x + y;\n  }\n\n  export class MyClass {\n    public method1(): void {\n      console.log('Method 1 called');\n    }\n  }\n}\n\nconsole.log(MyNamespace.MY_CONSTANT);  // 'Hello World'\nconsole.log(MyNamespace.myFunction(1, 2));  // 3\n\nconst obj = new MyNamespace.MyClass();\nobj.method1();  // logs: 'Method 1 called'\n")),(0,i.kt)("p",null,"In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyNamespace")," namespace is defined with the ",(0,i.kt)("inlineCode",{parentName:"p"},"namespace")," keyword, and it contains a constant, a function, and a class. The ",(0,i.kt)("inlineCode",{parentName:"p"},"MY_CONSTANT")," constant, the ",(0,i.kt)("inlineCode",{parentName:"p"},"myFunction")," function, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyClass")," class are exported from the namespace using the ",(0,i.kt)("inlineCode",{parentName:"p"},"export")," keyword, which makes them available to other parts of the code. The ",(0,i.kt)("inlineCode",{parentName:"p"},"MY_CONSTANT")," constant, the ",(0,i.kt)("inlineCode",{parentName:"p"},"myFunction")," function, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyClass")," class can be accessed using the ",(0,i.kt)("inlineCode",{parentName:"p"},"MyNamespace")," namespace name as a prefix."),(0,i.kt)("p",null,"Namespaces are a useful feature of TypeScript that allow you to organize and group related code under a single name, and they can help to prevent naming conflicts and collisions with other code. It is important to use namespaces appropriately to ensure that the code is well-organized and easy to understand and maintain."),(0,i.kt)("h3",{id:"what-are-generics"},"What are Generics?"),(0,i.kt)("p",null,"In TypeScript, generics are a way to create flexible and reusable code that can work with multiple types. Generics allow you to define a function, class, interface, or type that can accept one or more type parameters, which represent the types of the arguments, properties, or other elements of the code."),(0,i.kt)("p",null,"Generics allow you to write code that is generic, or not tied to a specific type, and that can work with any type or a set of types that you specify. You can use generics to create functions, classes, interfaces, or types that are more flexible and adaptable, and that can be used in a variety of contexts and scenarios."),(0,i.kt)("p",null,"Here is an example of using generics in TypeScript:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"function identity<T>(arg: T): T {\n  return arg;\n}\n\nconsole.log(identity('hello'));  // 'hello'\nconsole.log(identity(42));       // 42\n\nclass MyClass<T> {\n  value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n\n  getValue(): T {\n    return this.value;\n  }\n}\n\nconst obj1 = new MyClass<string>('hello');\nconsole.log(obj1.getValue());  // 'hello'\n\nconst obj2 = new MyClass<number>(42);\nconsole.log(obj2.getValue());  // 42\n")),(0,i.kt)("p",null,"Generics are a powerful and versatile feature of TypeScript that allow you to create flexible and reusable code that can work with multiple types, and they can be useful for creating generic functions, classes, interfaces, or types that can be used in a variety of contexts and scenarios. It is important to use generics appropriately to ensure that the code is well-typed and easy to understand and maintain."),(0,i.kt)("h3",{id:"what-are-template-literal-types"},"What are template literal types?"),(0,i.kt)("p",null,"Template literal types are a useful way to enforce the type of a string literal or a string template expression, and they can help to prevent errors and improve code quality by ensuring that a string has the correct format or content. They are also a useful way to create more expressive and readable types, and to improve the readability and the maintainability of your code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type Greeting = `Hello, ${'world'}!`;\ntype Name = `${'John'} ${'Doe'}`;\n\nlet greeting: Greeting = 'Hello, world!';  // ok\nlet name: Name = 'John Doe';  // ok\n\nlet x: Greeting = 'Hi, world!';  // error: Type '\"Hi, world!\"' is not assignable to type 'Greeting'\nlet y: Name = 'Jane Doe';  // error: Type '\"Jane Doe\"' is not assignable to type 'Name'\n")),(0,i.kt)("h3",{id:"what-is-conditional-type-and-how-to-create"},"What is conditional type and how to create?"),(0,i.kt)("p",null,"Conditional types are a powerful and flexible way to create complex and dynamic types in TypeScript, and they can be used in a variety of scenarios to model the behavior and the structure of a type. They are particularly useful for creating generic types that can adapt to different types or conditions, and for creating types that can model the conditional behavior of a value or an expression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type IsString<T> = T extends string ? true : false;\n\ntype A = IsString<'hello'>;  // type A is equal to true\ntype B = IsString<123>;  // type B is equal to false\n\ntype ToString<T> = T extends string ? T : string;\n\ntype C = ToString<'hello'>;  // type C is equal to 'hello'\ntype D = ToString<123>;  // type D is equal to string\n\ntype ToNumber<T> = T extends number ? T : number;\n\ntype E = ToNumber<'hello'>;  // type E is equal to number\ntype F = ToNumber<123>;  // type F is equal to 123\n")),(0,i.kt)("h3",{id:"what-utility-types-exist-and-their-usage"},"What utility types exist and their usage"),(0,i.kt)("p",null,"TypeScript provides a set of utility types that can be used to create and manipulate types in a more expressive and flexible way. Some of the utility types provided by TypeScript are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Partial<T>"),": This type creates a new type that represents the partial version of a type ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),". The partial version of a type has all the properties of the original type, but they are all optional. This type is useful for creating types that represent a subset of the properties of another type, or for creating types that can be used to partially update the properties of another type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Readonly<T>"),": This type creates a new type that represents the read-only version of a type ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),". The read-only version of a type has all the properties of the original type, but they are all read-only. This type is useful for creating types that cannot be modified, and for creating types that can only be used for reading the properties of another type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Pick<T, K>"),": This type creates a new type that represents a subset of the properties of a type ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),", selected by a set of keys ",(0,i.kt)("inlineCode",{parentName:"li"},"K"),". This type is useful for creating types that represent a subset of the properties of another type, based on a specific set of keys."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Omit<T, K>"),": This type creates a new type that represents a subset of the properties of a type ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),", excluding a set of keys ",(0,i.kt)("inlineCode",{parentName:"li"},"K"),". This type is useful for creating types that represent a subset of the properties of another type, excluding a specific set of keys."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Record<K, T>"),": This type creates a new type that represents an object with a set of keys ",(0,i.kt)("inlineCode",{parentName:"li"},"K")," and values of type ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),". This type is useful for creating types that represent objects with a specific set of keys and values."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Exclude<T, U>"),": This type creates a new type that represents the set of values that are in a type ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," but not in a type ",(0,i.kt)("inlineCode",{parentName:"li"},"U"),". This type is useful for creating types that represent the set of values that are in one type but not in another type."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Extract<T, U>"),": This type creates a new type that represents the set of values that are in a type ",(0,i.kt)("inlineCode",{parentName:"li"},"T")," and also in a type ",(0,i.kt)("inlineCode",{parentName:"li"},"U"),". This type is useful for creating types that represent the set of values that are in both types."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ReturnType<T>"),": This type creates a new type that represents the return type of a function or a method ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),". This type is useful for creating types that represent the return type of a function or a method."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"InstanceType<T>"),": This type creates a new type that represents the instance type of a class or a constructor function ",(0,i.kt)("inlineCode",{parentName:"li"},"T"),". This type is useful for creating types that represent the instance type of a class or a constructor function.  ")),(0,i.kt)("p",null,"These are some of the utility types provided by TypeScript, and they can be used to create and manipulate types in a more expressive and flexible way. It is important to understand the role and the use of these utility types in TypeScript, and to use them appropriately in your code."))}c.isMDXComponent=!0}}]);