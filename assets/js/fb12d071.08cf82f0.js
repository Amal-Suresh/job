"use strict";(self.webpackChunkjob=self.webpackChunkjob||[]).push([[32],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},s=Object.keys(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(i=0;i<s.length;i++)n=s[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),h=a,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||s;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,o=new Array(s);o[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r[d]="string"==typeof e?e:a,o[1]=r;for(var c=2;c<s;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},368:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const s={sidebar_position:99,title:"Common"},o="Common Programming Questions",r={unversionedId:"questions/common",id:"questions/common",title:"Common",description:"What is code refactoring?",source:"@site/interview/questions/common.md",sourceDirName:"questions",slug:"/questions/common",permalink:"/interview/questions/common",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/questions/common.md",tags:[],version:"current",sidebarPosition:99,frontMatter:{sidebar_position:99,title:"Common"},sidebar:"tutorialSidebar",previous:{title:"NodeJS",permalink:"/interview/questions/nodejs"}},l={},c=[{value:"What is code refactoring?",id:"what-is-code-refactoring",level:3},{value:"What is CORS?",id:"what-is-cors",level:3},{value:"SPA vs MPA",id:"spa-vs-mpa",level:3},{value:"What is Memoization?",id:"what-is-memoization",level:3},{value:"What is monolithic architecture?",id:"what-is-monolithic-architecture",level:3},{value:"What is Microservice architecture?",id:"what-is-microservice-architecture",level:3},{value:"What is SOLID?",id:"what-is-solid",level:2},{value:"Single Responsibility Principle",id:"single-responsibility-principle",level:3},{value:"Open-Closed Principle",id:"open-closed-principle",level:3},{value:"Liskov Substitution Principle",id:"liskov-substitution-principle",level:3},{value:"Interface Segregation Principle",id:"interface-segregation-principle",level:3},{value:"Dependency Inversion Principle",id:"dependency-inversion-principle",level:3}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"common-programming-questions"},"Common Programming Questions"),(0,a.kt)("h3",{id:"what-is-code-refactoring"},"What is code refactoring?"),(0,a.kt)("h3",{id:"what-is-cors"},"What is CORS?"),(0,a.kt)("p",null,"CORS (Cross-Origin Resource Sharing) is a security mechanism that is used to restrict or allow the communication between web pages and servers that are hosted on different domains. It consists of a set of rules and headers that are used to specify the conditions under which a web page is allowed to make requests to a server, and to allow or deny the responses of the server to be accessed by the web page."),(0,a.kt)("p",null,"CORS is implemented by the browser, and it is based on the HTTP headers that are sent with the requests and the responses. The browser checks the headers of the requests and the responses, and it compares the origin of the requests (the domain of the web page) with the origin of the responses (the domain of the server). If the origins match, the browser allows the requests and the responses to be sent and received, and if the origins do not match, the browser blocks the requests and the responses, and it sends an error message to the web page."),(0,a.kt)("p",null,"CORS is used to prevent web pages from making requests to servers that are hosted on different domains, and to prevent servers from sending responses to web pages that are hosted on different domains. It is used to protect the privacy and the security of the users, and to prevent web pages from making malicious or unauthorized requests to servers."),(0,a.kt)("p",null,"CORS is an important security mechanism in web development, and it is important to understand how it works and how to use it properly in your web applications. It is also important to be aware of the limitations and the potential issues that CORS can cause, and to know how to troubleshoot and debug CORS errors in your web applications."),(0,a.kt)("h3",{id:"spa-vs-mpa"},"SPA vs MPA"),(0,a.kt)("p",null,"Single Page Applications (SPAs) and Multiple Page Applications (MPAs) are two different architectures for building web applications."),(0,a.kt)("p",null,"Single Page Applications (SPAs) are web applications that are designed to work as a single page. They are built using client-side technologies such as HTML, CSS, and JavaScript, and they are loaded in the browser as a single HTML document. SPAs use a combination of client-side rendering, data binding, and AJAX (Asynchronous JavaScript and XML) to update the content and the layout of the page without reloading the page. SPAs are fast and responsive, and they offer a seamless and immersive experience to the users."),(0,a.kt)("p",null,"Multiple Page Applications (MPAs) are web applications that are built using server-side technologies such as PHP, ASP.NET, or Java, and that are composed of multiple pages that are served by the server. MPAs use a combination of server-side rendering, templates, and server-side logic to generate and update the content and the layout of the pages. MPAs are slower and less responsive than SPAs, as they require the reloading of the page to update the content and the layout."),(0,a.kt)("p",null,"Here are some guidelines on when to use SPAs or MPAs:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Use SPAs when you need fast and seamless navigation: SPAs are suitable for web applications that require fast and seamless navigation, such as online stores, social networks, or collaboration tools. SPAs offer a fast and responsive experience to the users, and they allow the users to navigate and interact with the web application without reloading the page.   "),(0,a.kt)("li",{parentName:"ul"},"Use MPAs when you need complex server-side logic or data processing: MPAs are suitable for web applications that require complex server-side logic or data processing, such as enterprise applications, reporting tools, or data-intensive applications. MPAs allow you to use server-side technologies and languages to process and manipulate data, and to generate and update the content and the layout of the pages. "),(0,a.kt)("li",{parentName:"ul"},"Use SPAs when you need to optimize the performance and the scalability of the web application: SPAs are suitable for web applications that need to optimize the performance and the scalability, as they require fewer server resources and bandwidth, and they offer a faster and more efficient experience to the users. SPAs use client-side rendering and data binding to update the content and the layout of the page, and they use AJAX to communicate with the server asynchronously, without reloading the page."),(0,a.kt)("li",{parentName:"ul"},"Use MPAs when you need to support legacy systems or technologies: MPAs are suitable for web applications that need to support legacy systems or technologies, as they allow you to use server-side technologies and languages to integrate with the legacy systems and the APIs. MPAs allow you to use server-side rendering and templates to generate and update the content and the layout of the pages, and they allow you to use server-side logic to manipulate and process data.")),(0,a.kt)("h3",{id:"what-is-memoization"},"What is Memoization?"),(0,a.kt)("p",null,"Memoization is an optimization technique which passes a complex function to be memoized. In memoization, the result is \u201cremembered\u201d when the same parameters are passed-in subsequently."),(0,a.kt)("h3",{id:"what-is-monolithic-architecture"},"What is monolithic architecture?"),(0,a.kt)("p",null,"A monolithic architecture means that your app is written as one cohesive unit of code whose components are designed to work together, sharing the same memory space and resources."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Benefits of Monolithic Architecture:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Simple to develop."),(0,a.kt)("li",{parentName:"ul"},"Simple to test. For example you can implement end-to-end testing by simply launching the application and testing the UI with Selenium."),(0,a.kt)("li",{parentName:"ul"},"Simple to deploy. You just have to copy the packaged application to a server."),(0,a.kt)("li",{parentName:"ul"},"Simple to scale horizontally by running multiple copies behind a load balancer.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Drawbacks of Monolithic Architecture:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"This simple approach has a limitation in size and complexity."),(0,a.kt)("li",{parentName:"ul"},"Application is too large and complex to fully understand and made changes fast and correctly."),(0,a.kt)("li",{parentName:"ul"},"The size of the application can slow down the start-up time."),(0,a.kt)("li",{parentName:"ul"},"You must redeploy the entire application on each update."),(0,a.kt)("li",{parentName:"ul"},"Impact of a change is usually not very well understood which leads to do extensive manual testing."),(0,a.kt)("li",{parentName:"ul"},"Continuous deployment is difficult."),(0,a.kt)("li",{parentName:"ul"},"Monolithic applications can also be difficult to scale when different modules have conflicting resource requirements."),(0,a.kt)("li",{parentName:"ul"},"Another problem with monolithic applications is reliability. Bug in any module (e.g. memory leak) can potentially bring down the entire process. Moreover, since all instances of the application are identical, that bug will impact the availability of the entire application."),(0,a.kt)("li",{parentName:"ul"},"Monolithic applications has a barrier to adopting new technologies. Since changes in frameworks or languages will affect an entire application it is extremely expensive in both time and cost.")),(0,a.kt)("p",null,"Monolithic Pros: The major advantage of the monolithic architecture is that most apps typically have a large number of cross-cutting concerns, such as logging, rate limiting, and security features such audit trails and DOS protection."),(0,a.kt)("p",null,"When everything is running through the same app, it\u2019s easy to hook up components to those cross-cutting concerns."),(0,a.kt)("p",null,"There can also be performance advantages, since shared-memory access is faster than inter-process communication (IPC)."),(0,a.kt)("p",null,"Monolithic cons: Monolithic app services tend to get tightly coupled and entangled as the application evolves, making it difficult to isolate services for purposes such as independent scaling or code maintainability."),(0,a.kt)("p",null,"Monolithic architectures are also much harder to understand, because there may be dependencies, side-effects, and magic which are not obvious when you\u2019re looking at a particular service or controller."),(0,a.kt)("h3",{id:"what-is-microservice-architecture"},"What is Microservice architecture?"),(0,a.kt)("p",null,"A microservice architecture means that your app is made up of lots of smaller, independent applications capable of running in their own memory space and scaling independently from each other across potentially many separate machines."),(0,a.kt)("p",null,"The idea is to split your application into a set of smaller, interconnected services instead of building a single monolithic application. The Microservice architecture pattern significantly impacts the relationship between the application and the database. Instead of sharing a single database schema with other services, each service has its own database schema. Mobile, desktop, web apps don't have direct access to services but they have access to API Gateway. It is responsible for tasks such as load balancing, caching, access control, API metering, and monitoring."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Benefits of Microservices Architecture:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It tackles the problem of complexity by decomposing application into a set of manageable services which are much faster to develop, and much easier to understand and maintain."),(0,a.kt)("li",{parentName:"ul"},"It enables each service to be developed independently by a team that is focused on that service."),(0,a.kt)("li",{parentName:"ul"},"It reduces barrier of adopting new technologies since the developers are free to choose whatever technologies make sense for their service and not bounded to the choices made at the start of the project."),(0,a.kt)("li",{parentName:"ul"},"Microservice architecture enables each microservice to be deployed independently. As a result, it makes continuous deployment possible for complex applications."),(0,a.kt)("li",{parentName:"ul"},"Microservice architecture enables each service to be scaled independently.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Drawbacks of Microservices Architecture:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Microservices architecture adding a complexity to the project just by the fact that a microservices application is a distributed system. You need to choose and implement an inter-process communication mechanism based on either messaging or RPC and write code to handle partial failure and take into account other fallacies of distributed computing."),(0,a.kt)("li",{parentName:"ul"},"Microservices has the partitioned database architecture. Business transactions that update multiple business entities in a microservices-based application need to update multiple databases owned by different services. Using distributed transactions is usually not an option and you end up having to use an eventual consistency based approach, which is more challenging for developers."),(0,a.kt)("li",{parentName:"ul"},"Testing a microservices application is also much more complex then in case of monolithic web application. For a similar test for a service you would need to launch that service and any services that it depends upon (or at least configure stubs for those services)."),(0,a.kt)("li",{parentName:"ul"},"It is more difficult to implement changes that span multiple services. In a monolithic application you could simply change the corresponding modules, integrate the changes, and deploy them in one go. In a Microservice architecture you need to carefully plan and coordinate the rollout of changes to each of the services."),(0,a.kt)("li",{parentName:"ul"},"Deploying a microservices-based application is also more complex. A monolithic application is simply deployed on a set of identical servers behind a load balancer. In contrast, a microservice application typically consists of a large number of services. Each service will have multiple runtime instances. And each instance need to be configured, deployed, scaled, and monitored. In addition, you will also need to implement a service discovery mechanism. Manual approaches to operations cannot scale to this level of complexity and successful deployment a microservices application requires a high level of automation.")),(0,a.kt)("p",null,"Microservice pros: Microservice architectures are typically better organized, since each microservice has a very specific job, and is not concerned with the jobs of other components. Decoupled services are also easier to recompose and reconfigure to serve the purposes of different apps (for example, serving both the web clients and public API)."),(0,a.kt)("p",null,"Microservice cons: As you\u2019re building a new microservice architecture, you\u2019re likely to discover lots of cross-cutting concerns that you did not anticipate at design time. A monolithic app could establish shared magic helpers or middleware to handle such cross-cutting concerns without much effort."),(0,a.kt)("h2",{id:"what-is-solid"},"What is SOLID?"),(0,a.kt)("p",null,"SOLID is a set of five principles of object-oriented software design. These principles were first proposed by Robert C. Martin in the early 2000s and have since become a widely accepted set of best practices for designing maintainable, scalable, and flexible software systems."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"The five principles of SOLID are:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Single Responsibility Principle (SRP): This principle states that a class should have only one reason to change, and that it should have a single, well-defined responsibility."),(0,a.kt)("li",{parentName:"ol"},"Open-Closed Principle (OCP): This principle states that a class should be open for extension, but closed for modification. This means that it should be easy to add new functionality to a class, but the existing code should not need to be modified."),(0,a.kt)("li",{parentName:"ol"},"Liskov Substitution Principle (LSP): This principle states that a subclass should be able to be used as a substitute for its superclass, without altering the correctness of the program."),(0,a.kt)("li",{parentName:"ol"},"Interface Segregation Principle (ISP): This principle states that a client should not depend on interfaces it does not use. This means that a class should not be forced to implement unnecessary methods."),(0,a.kt)("li",{parentName:"ol"},"Dependency Inversion Principle (DIP): This principle states that high-level modules should not depend on low-level modules, but rather both should depend on abstractions. This helps to decouple the modules and makes them more flexible and maintainable.")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"By following the SOLID principles, developers can design software systems that are easier to understand, maintain, and extend over time.")),(0,a.kt)("h3",{id:"single-responsibility-principle"},"Single Responsibility Principle"),(0,a.kt)("p",null,"A class should be responsible for only one thing. If a class is responsible for several tasks, its subsystems, which implement these tasks, are related to each other. Changes in one such subsystem lead to changes in another."),(0,a.kt)("p",null,"Below is an example that does not conform to the single responsibility principle:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class TodoList {\n    constructor() {\n        this.items = []\n    }\n\n    addItem(text) {\n        this.items.push(text)\n    }\n\n    removeItem(index) {\n        this.items = items.splice(index, 1)\n    }\n\n    toString() {\n        return this.items.toString()\n    }\n\n    save(filename) {\n        fs.writeFileSync(filename, this.toString())\n    }\n\n    load(filename) { // Some implementation }\n}\n")),(0,a.kt)("p",null,"Try to refactor the code before seeing a solution"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Example Solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"class TodoList {\n    constructor() {\n        this.items = [];\n    }\n    addItem(text) {\n        this.items.push(text);\n    }\n    removeItem(index) {\n        this.items = items.splice(index, 1);\n    }\n    toString() {\n        return this.items.toString();\n    }\n}\n\nclass TodoDBManager {\n    saveToFile(data, filename) {\n        fs.writeFileSync(filename, data.toString());\n    }\n    loadFromFile(filename) {\n        // Some implementation\n    }\n}\n"))),(0,a.kt)("h3",{id:"open-closed-principle"},"Open-Closed Principle"),(0,a.kt)("p",null,"Program entities (classes, modules, functions) must be open for extension, but not for modification."),(0,a.kt)("p",null,"Let's continue with ",(0,a.kt)("inlineCode",{parentName:"p"},"TodoList")," class, check code below and try to refactor it according open-closed principle:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"enum EStatus {\n    pending,\n    progress,\n    completed,\n}\n\ninterface ITodo {\n    status: EStatus;\n    // ...other todo fields\n}\n\nclass TodoList {\n    items: ITodo[];\n\n    processTodos(status: EStatus) {\n        for (const todo of this.items) {\n            if (todo.status === EStatus.pending) {\n                // ...logic1\n            }\n            if (todo.status === EStatus.progress) {\n                // ...logic2\n            }\n            if (todo.status === EStatus.completed) {\n                // ...logic3\n            }\n        }\n    }\n}\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Example Solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class TodoList {\n    processTodos(status, cb) {\n        for (const todo of this.items) {\n            if (todo.status === status) {\n                cb();\n            }\n        }\n    }\n}\n"))),(0,a.kt)("h3",{id:"liskov-substitution-principle"},"Liskov Substitution Principle"),(0,a.kt)("p",null,"If you have a function, that works for a base type, it should work for a derived type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class TodoList {\n    items: ITodo[];\n\n    getAllItems() {\n        return this.items;\n    }\n\n}\n\nclass PendingTodoList extends TodoList {\n    constructor() {\n        super();\n    }\n}\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Example Solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class PendingTodoList extends TodoList {\n    getAllItems() {\n        return this.items.filter(it => it.status === EStatus.pending);\n    }\n}\n"))),(0,a.kt)("h3",{id:"interface-segregation-principle"},"Interface Segregation Principle"),(0,a.kt)("p",null,"Create highly specialized interfaces designed for a specific client. Customers should not be dependent on interfaces that they do not use."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface ITodoList {\n    items: ITodo[];\n}\n\ninterface IWeatherList extends ITodoList {\n    getWeather: () => void;\n    getWeekForecast: () => void;\n}\n\nclass TodoList implements IWeatherList {\n    constructor(items: ITodo[]) {\n        this.items = items;\n    }\n}\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Example Solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"class TodoList implements ITodoList {}\n"))),(0,a.kt)("h3",{id:"dependency-inversion-principle"},"Dependency Inversion Principle"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Top-level modules should not depend on lower-level modules. Both types of modules should depend on abstractions."),(0,a.kt)("li",{parentName:"ul"},"Abstractions should not depend on parts. Parts should depend on abstractions.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"interface ITodo {}\n\nabstract class DB {\n    data: ITodo[];\n    save: (data: ITodo[]) => void;\n}\n\nclass LocalDB {\n    saveTodos(items: ITodo[]) {\n        // ...logic\n    }\n}\n\nclass ExternalDB {\n    saveTodos(items: ITodo[]) {\n        // ...logic\n    }\n}\n\nclass TodoListDB extends DB {\n    data: ITodo[];\n\n    save(db) {\n        db.saveTodos(this.items);\n    }\n}\n")),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Example Solution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"abstract class DB {\n    save: <T>(data: T[]) => void;\n}\n\nclass LocalDB extends DB {\n    save(data) {\n        // logic\n    }\n}\n\nclass ExternalDB extends DB {\n    save(data) {\n        // logic\n    }\n}\n\nclass TodoList {\n    saveTodos(db: DB) {\n        db.save(this.items);\n    }\n}\n"))))}d.isMDXComponent=!0}}]);