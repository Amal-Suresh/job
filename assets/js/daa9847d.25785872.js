"use strict";(self.webpackChunkjob=self.webpackChunkjob||[]).push([[750],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>h});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=o.createContext({}),p=function(e){var t=o.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return o.createElement(i.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},d=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,i=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=p(n),d=r,h=c["".concat(i,".").concat(d)]||c[d]||u[d]||a;return n?o.createElement(h,s(s({ref:t},m),{},{components:n})):o.createElement(h,s({ref:t},m))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=d;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[c]="string"==typeof e?e:r,s[1]=l;for(var p=2;p<a;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}d.displayName="MDXCreateElement"},3738:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var o=n(7462),r=(n(7294),n(3905));const a={},s="What are the types of memory leaks in NodeJS?",l={unversionedId:"questions/nodejs/memory-leaks",id:"questions/nodejs/memory-leaks",title:"What are the types of memory leaks in NodeJS?",description:"A memory leak is a condition that occurs when a program doesn't release the memory it allocates. For instance, the system assigns memory locations to store values for the variables that we declare inside our program.",source:"@site/interview/questions/nodejs/memory-leaks.md",sourceDirName:"questions/nodejs",slug:"/questions/nodejs/memory-leaks",permalink:"/questions/nodejs/memory-leaks",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/questions/nodejs/memory-leaks.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"What is load balancer?",permalink:"/questions/nodejs/load-balancer"},next:{title:"How microservices communicate with each other?",permalink:"/questions/nodejs/microservices-communication"}},i={},p=[{value:"How to prevent memory leaks in Node.js?",id:"how-to-prevent-memory-leaks-in-nodejs",level:2}],m={toc:p};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"what-are-the-types-of-memory-leaks-in-nodejs"},"What are the types of memory leaks in NodeJS?"),(0,r.kt)("p",null,"A memory leak is a condition that occurs when a program doesn't release the memory it allocates. For instance, the system assigns memory locations to store values for the variables that we declare inside our program."),(0,r.kt)("p",null,"High-level programming languages such as JavaScript utilize automatic memory management, known as garbage collection. Garbage collection allocates the memory to a variable once we declare it and reclaims the memory once it is no longer needed. Unfortunately, even though JavaScript uses a garbage collector to release the memory, sometimes determining whether to free the memory or not is undecidable."),(0,r.kt)("p",null,"The common causes of Memory Leaks in Node.JS are:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1. Global variables:")),(0,r.kt)("p",null,"This is one of the most common causes of leaks in Node. Due to the nature of JavaScript as a language, it is very easy to add to global variables and resources. If these are not cleaned over time, they keep adding up and eventually crash the application."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const http = require("http");\n\nconst requestLogs = []; // causing the memory leak\nconst server = http.createServer((req, res) => {\n    requestLogs.push({ url: req.url, array: new Array(10000).join("*")\n    res.end(JSON.stringify(requestLogs));\n});\n\nserver.listen(3000);\nconsole.log("Server listening to port 3000. Press Ctrl+C to stop it.");\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2. Closures:")),(0,r.kt)("p",null,"Closures memorize their surrounding context. When a closure holds a reference to a large object in heap, it keeps the object in memory as long as the closure is in use."),(0,r.kt)("p",null,"This implies easily ending up in situations where a closure holding such a reference can be improperly used leading to a memory leak."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3. Timers & Events:")),(0,r.kt)("p",null,"The use of setTimeout, setInterval, Observers, and event listeners can cause memory leaks when heavy object references are kept in their callbacks without proper handling."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"4. Multiple references:")),(0,r.kt)("p",null,"If you reference the same object from multiple objects, it can lead to a memory leak if one of the references is garbage collected while the other one is left dangling."),(0,r.kt)("h2",{id:"how-to-prevent-memory-leaks-in-nodejs"},"How to prevent memory leaks in Node.js?"),(0,r.kt)("p",null,"Tools to help debug memory leaks:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1. Node-heapdump:")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"node-heapdump")," module is good for postmortem debugging. It generates heap dumps on your SIGUSR2. To help catch bugs easily in a development environment, add ",(0,r.kt)("inlineCode",{parentName:"p"},"node-heapdump")," as a dependency to your project like so:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const heapdump = require("heapdump");\n\nheapdump.writeSnapshot(function (err, filename) {\n  console.log("Sample dump written to", filename);\n});\n')),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2. Clinic.js:")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"clinic.js")," is a handy toolset to diagnose and pinpoint performance bottlenecks in your Node applications. The ",(0,r.kt)("inlineCode",{parentName:"p"},"clinic.js")," HeapProfiler uses flame graphs to highlight memory allocations. You can use it with tools such as AutoCannon to simulate HTTP load when profiling."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3. The process.memoryUsage method:")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"process.memoryUsage")," method provides a simple way of monitoring memory usage in your Node applications."),(0,r.kt)("p",null,"The method returns an object with the following properties:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"rss:"),", or resident set size, refers to the amount of space occupied in the main memory for the process, which includes code segment, heap, and stack. If your RSS is going up, there is a likelihood your application is leaking memory"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"heapTotal:"),", the total amount of memory available for JavaScript objects"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"heapUsed:"),", the total amount of memory occupied by JavaScript objects"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"external:"),", the amount of memory consumed by off-heap data (buffers) used by Node; this is where objects, strings, and closures are stored"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"arrayBuffers:"),", the amount of memory allocation for ArrayBuffers and SharedArrayBuffers (the external memory size also includes this memory value)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"console.log(process.memoryUsage());\n\n{\n  rss: 4935680,\n  heapTotal:1826816,\n  heapUsed:650472,\n  external: 49879,\n  arrayBuffers: 17310,\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"4. Node Inspector:")),(0,r.kt)("p",null,"Node Inspector is a debugger interface for Node applications. Run Node with the \u2013inspect flag to use it, and it starts listening for a debugging client. It is one of the simplest ways of capturing heap snapshots with Chrome DevTools."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"5. Chrome DevTools:")),(0,r.kt)("p",null,"Chrome offers a range of tools to help debug your memory and performance issues, including allocation timelines, sampling heap profiler, and heap snapshots etc."))}c.isMDXComponent=!0}}]);