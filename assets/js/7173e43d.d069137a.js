"use strict";(self.webpackChunkjob=self.webpackChunkjob||[]).push([[7802],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(n),h=o,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||a;return n?r.createElement(m,s(s({ref:t},d),{},{components:n})):r.createElement(m,s({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[p]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},6894:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const a={},s="How does CSS work under the hood?",i={unversionedId:"questions/frontend/css-engine",id:"questions/frontend/css-engine",title:"How does CSS work under the hood?",description:"The CSS language is designed to be used alongside a \"markup\" language like HTML. CSS defines how HTML elements are formatted \u2013 controlling their layout, colors, fonts, and so on. When a browser displays a document, it must combine the document's content with its style information. It processes the document in a number of stages, which we've listed below.",source:"@site/interview/questions/frontend/css-engine.md",sourceDirName:"questions/frontend",slug:"/questions/frontend/css-engine",permalink:"/questions/frontend/css-engine",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/questions/frontend/css-engine.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:'Explain the CSS "box model"',permalink:"/questions/frontend/css-box-model"},next:{title:"When to use css grid and flexbox?",permalink:"/questions/frontend/css-grid-vs-flexbox"}},l={},c=[],d={toc:c};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"how-does-css-work-under-the-hood"},"How does CSS work under the hood?"),(0,o.kt)("p",null,"The CSS language is designed to be used alongside a \"markup\" language like HTML. CSS defines how HTML elements are formatted \u2013 controlling their layout, colors, fonts, and so on. When a browser displays a document, it must combine the document's content with its style information. It processes the document in a number of stages, which we've listed below."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The browser loads the HTML (e.g. receives it from the network)."),(0,o.kt)("li",{parentName:"ol"},"It converts the HTML into a DOM (Document Object Model)."),(0,o.kt)("li",{parentName:"ol"},"The browser then fetches most of the resources that are linked to by the HTML document, such as embedded images and videos and linked CSS."),(0,o.kt)("li",{parentName:"ol"},'The browser parses the fetched CSS, and sorts the different rules by their selector types into different "buckets", e.g. element, class, ID, and so on. Based on the selectors it finds, it works out which rules should be applied to which nodes in the DOM, and attaches style to them as required (this intermediate step is called a render tree).'),(0,o.kt)("li",{parentName:"ol"},"The render tree is laid out in the structure it should appear in after the rules have been applied to it."),(0,o.kt)("li",{parentName:"ol"},"The visual display of the page is shown on the screen (this stage is called painting).")),(0,o.kt)("p",null,"The following diagram also offers a simple view of the process."),(0,o.kt)("img",{src:"/img/css-process.png",alt:"CSS Process"}),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"The DOM and CSSOM:")),(0,o.kt)("p",null,"A DOM has a tree-like structure. Each element, attribute, and piece of text in the markup language becomes a DOM node in the tree structure. The nodes are defined by their relationship to other DOM nodes. Some elements are parents of child nodes, and child nodes have siblings. The browser undergo a process that includes conversion, tokenization, lexing, and parsing which ultimately constructs the DOM and CSSOM."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Conversion"),": Reading raw bytes of HTML and CSS off the disk or network."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Tokenization"),": Breaking input into chunks (ex: start tags, end tags, attribute names, attribute values), striping irrelevant characters such as whitespace and line breaks."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Lexing"),": Like the tokenizer, but it also identifies the type of each token (this token is a number, that token is a string literal, this other token is an equality operator)."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Parsing"),": Takes the stream of tokens from the lexer, interprets the tokens using a specific grammar, and turns it into an abstract syntax tree.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example:"),"\xa0DOM Representation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<p>\n  Let's use:\n  <span>Cascading</span>\n  <span>Style</span>\n  <span>Sheets</span>\n</p>\n")),(0,o.kt)("p",null,"In the DOM, the node corresponding to our\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"<p>"),"\xa0element is a parent. Its children are a text node and the three nodes corresponding to our\xa0",(0,o.kt)("inlineCode",{parentName:"p"},"<span>"),"\xa0elements. The SPAN nodes are also parents, with text nodes as their children:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'P\n\u251c\u2500 "Let\'s use:"\n\u251c\u2500 SPAN\n|  \u2514\u2500 "Cascading"\n\u251c\u2500 SPAN\n|  \u2514\u2500 "Style"\n\u2514\u2500 SPAN\n   \u2514\u2500 "Sheets"\n')),(0,o.kt)("p",null,"Applying CSS to the DOM"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-css"},"span {\n  border: 1px solid black;\n  background-color: lime;\n}\n")),(0,o.kt)("p",null,"Once both tree structures are created, the rendering engine then attaches the data structures into what's called a render tree as part of the layout process. The render tree is a visual representation of the document which enable painting the contents of the page in their correct order."),(0,o.kt)("p",null,"Render tree construction follows the following order:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Starting at the root of the DOM tree, traverse each visible node."),(0,o.kt)("li",{parentName:"ul"},"Omit non visible nodes."),(0,o.kt)("li",{parentName:"ul"},"For each visible node find the appropriate matching CSSOM rules and apply them."),(0,o.kt)("li",{parentName:"ul"},"Emit visible nodes with content and their computed styles."),(0,o.kt)("li",{parentName:"ul"},"Finally, output a render tree that contains both the content and style information of all visible content on the screen.")))}p.isMDXComponent=!0}}]);