"use strict";(self.webpackChunkjob=self.webpackChunkjob||[]).push([[32],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var s=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,s,i=function(e,t){if(null==e)return{};var n,s,i={},o=Object.keys(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(s=0;s<o.length;s++)n=o[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=s.createContext({}),c=function(e){var t=s.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=c(e.components);return s.createElement(r.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},m=s.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,h=p["".concat(r,".").concat(m)]||p[m]||u[m]||o;return n?s.createElement(h,a(a({ref:t},d),{},{components:n})):s.createElement(h,a({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=m;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l[p]="string"==typeof e?e:i,a[1]=l;for(var c=2;c<o;c++)a[c]=n[c];return s.createElement.apply(null,a)}return s.createElement.apply(null,n)}m.displayName="MDXCreateElement"},368:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var s=n(7462),i=(n(7294),n(3905));const o={sidebar_position:99},a="Common",l={unversionedId:"questions/common",id:"questions/common",title:"Common",description:"What is SOLID?",source:"@site/interview/questions/common.md",sourceDirName:"questions",slug:"/questions/common",permalink:"/interview/questions/common",draft:!1,editUrl:"https://github.com/izemil/job/edit/master/interview/questions/common.md",tags:[],version:"current",sidebarPosition:99,frontMatter:{sidebar_position:99},sidebar:"tutorialSidebar",previous:{title:"NodeJS",permalink:"/interview/questions/nodejs"},next:{title:"Tasks",permalink:"/interview/category/tasks"}},r={},c=[{value:"What is SOLID?",id:"what-is-solid",level:2},{value:"Single Responsibility Principle",id:"single-responsibility-principle",level:3},{value:"Open-Closed Principle",id:"open-closed-principle",level:3},{value:"Liskov Substitution Principle",id:"liskov-substitution-principle",level:3},{value:"Interface Segregation Principle",id:"interface-segregation-principle",level:3},{value:"Dependency Inversion Principle",id:"dependency-inversion-principle",level:3}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,s.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"common"},"Common"),(0,i.kt)("h2",{id:"what-is-solid"},"What is SOLID?"),(0,i.kt)("p",null,"SOLID is a set of five principles of object-oriented software design. These principles were first proposed by Robert C. Martin in the early 2000s and have since become a widely accepted set of best practices for designing maintainable, scalable, and flexible software systems."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The five principles of SOLID are:")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Single Responsibility Principle (SRP): This principle states that a class should have only one reason to change, and that it should have a single, well-defined responsibility."),(0,i.kt)("li",{parentName:"ol"},"Open-Closed Principle (OCP): This principle states that a class should be open for extension, but closed for modification. This means that it should be easy to add new functionality to a class, but the existing code should not need to be modified."),(0,i.kt)("li",{parentName:"ol"},"Liskov Substitution Principle (LSP): This principle states that a subclass should be able to be used as a substitute for its superclass, without altering the correctness of the program."),(0,i.kt)("li",{parentName:"ol"},"Interface Segregation Principle (ISP): This principle states that a client should not depend on interfaces it does not use. This means that a class should not be forced to implement unnecessary methods."),(0,i.kt)("li",{parentName:"ol"},"Dependency Inversion Principle (DIP): This principle states that high-level modules should not depend on low-level modules, but rather both should depend on abstractions. This helps to decouple the modules and makes them more flexible and maintainable.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"By following the SOLID principles, developers can design software systems that are easier to understand, maintain, and extend over time.")),(0,i.kt)("h3",{id:"single-responsibility-principle"},"Single Responsibility Principle"),(0,i.kt)("p",null,"A class should be responsible for only one thing. If a class is responsible for several tasks, its subsystems, which implement these tasks, are related to each other. Changes in one such subsystem lead to changes in another."),(0,i.kt)("p",null,"Below is an example that does not conform to the single responsibility principle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"class TodoList {\n    constructor() {\n        this.items = []\n    }\n\n    addItem(text) {\n        this.items.push(text)\n    }\n\n    removeItem(index) {\n        this.items = items.splice(index, 1)\n    }\n\n    toString() {\n        return this.items.toString()\n    }\n\n    save(filename) {\n        fs.writeFileSync(filename, this.toString())\n    }\n\n    load(filename) { // Some implementation }\n}\n")),(0,i.kt)("p",null,"Try to refactor the code before seeing a solution"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Example Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"class TodoList {\n    constructor() {\n        this.items = [];\n    }\n    addItem(text) {\n        this.items.push(text);\n    }\n    removeItem(index) {\n        this.items = items.splice(index, 1);\n    }\n    toString() {\n        return this.items.toString();\n    }\n}\n\nclass TodoDBManager {\n    saveToFile(data, filename) {\n        fs.writeFileSync(filename, data.toString());\n    }\n    loadFromFile(filename) {\n        // Some implementation\n    }\n}\n"))),(0,i.kt)("h3",{id:"open-closed-principle"},"Open-Closed Principle"),(0,i.kt)("p",null,"Program entities (classes, modules, functions) must be open for extension, but not for modification."),(0,i.kt)("p",null,"Let's continue with ",(0,i.kt)("inlineCode",{parentName:"p"},"TodoList")," class, check code below and try to refactor it according open-closed principle:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"enum EStatus {\n    pending,\n    progress,\n    completed,\n}\n\ninterface ITodo {\n    status: EStatus;\n    // ...other todo fields\n}\n\nclass TodoList {\n    items: ITodo[];\n\n    processTodos(status: EStatus) {\n        for (const todo of this.items) {\n            if (todo.status === EStatus.pending) {\n                // ...logic1\n            }\n            if (todo.status === EStatus.progress) {\n                // ...logic2\n            }\n            if (todo.status === EStatus.completed) {\n                // ...logic3\n            }\n        }\n    }\n}\n")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Example Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class TodoList {\n    processTodos(status, cb) {\n        for (const todo of this.items) {\n            if (todo.status === status) {\n                cb();\n            }\n        }\n    }\n}\n"))),(0,i.kt)("h3",{id:"liskov-substitution-principle"},"Liskov Substitution Principle"),(0,i.kt)("p",null,"If you have a function, that works for a base type, it should work for a derived type."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class TodoList {\n    items: ITodo[];\n\n    getAllItems() {\n        return this.items;\n    }\n\n}\n\nclass PendingTodoList extends TodoList {\n    constructor() {\n        super();\n    }\n}\n")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Example Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class PendingTodoList extends TodoList {\n    getAllItems() {\n        return this.items.filter(it => it.status === EStatus.pending);\n    }\n}\n"))),(0,i.kt)("h3",{id:"interface-segregation-principle"},"Interface Segregation Principle"),(0,i.kt)("p",null,"Create highly specialized interfaces designed for a specific client. Customers should not be dependent on interfaces that they do not use."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface ITodoList {\n    items: ITodo[];\n}\n\ninterface IWeatherList extends ITodoList {\n    getWeather: () => void;\n    getWeekForecast: () => void;\n}\n\nclass TodoList implements IWeatherList {\n    constructor(items: ITodo[]) {\n        this.items = items;\n    }\n}\n")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Example Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"class TodoList implements ITodoList {}\n"))),(0,i.kt)("h3",{id:"dependency-inversion-principle"},"Dependency Inversion Principle"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Top-level modules should not depend on lower-level modules. Both types of modules should depend on abstractions."),(0,i.kt)("li",{parentName:"ul"},"Abstractions should not depend on parts. Parts should depend on abstractions.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"interface ITodo {}\n\nabstract class DB {\n    data: ITodo[];\n    save: (data: ITodo[]) => void;\n}\n\nclass LocalDB {\n    saveTodos(items: ITodo[]) {\n        // ...logic\n    }\n}\n\nclass ExternalDB {\n    saveTodos(items: ITodo[]) {\n        // ...logic\n    }\n}\n\nclass TodoListDB extends DB {\n    data: ITodo[];\n\n    save(db) {\n        db.saveTodos(this.items);\n    }\n}\n")),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Example Solution"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"abstract class DB {\n    save: <T>(data: T[]) => void;\n}\n\nclass LocalDB extends DB {\n    save(data) {\n        // logic\n    }\n}\n\nclass ExternalDB extends DB {\n    save(data) {\n        // logic\n    }\n}\n\nclass TodoList {\n    saveTodos(db: DB) {\n        db.save(this.items);\n    }\n}\n"))))}p.isMDXComponent=!0}}]);